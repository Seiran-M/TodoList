import {Dispatch} from 'redux'import {AxiosError} from 'axios'import {addTodolistAC, removeTodolistAC, setTodolistsAC, TasksStateType} from './todolists-reducer'import {AppRootStateType} from '../store'import {TaskPriorities, tasksAPI, TaskStatuses, TaskType, UpdateTaskModelType} from '../../api/tasks-api'import {RequestStatusType, setAppStatusAC} from './app-reducer'import {handleServerAppError, handleServerNetworkError} from '../../utils/error-utils'import {TodolistType} from '../../api/todolists-api'import {createSlice, PayloadAction} from '@reduxjs/toolkit'const initialState: TasksStateType = {}const slice = createSlice({   name: 'tasks',   initialState,   reducers: {      removeTaskAC(state, action: PayloadAction<{ todolistId: string, taskId: string }>) {         const tasks = state[action.payload.todolistId]         const index = tasks.findIndex(t => t.id === action.payload.taskId)         if (index > -1) {            tasks.splice(index, 1)         }      },      addTaskAC(state, action: PayloadAction<{ task: TaskType }>) {         state[action.payload.task.todoListId].unshift(action.payload.task)      },      updateTaskAC(state, action: PayloadAction<{ taskId: string, model: UpdateDomainTaskModelType, todolistId: string }>) {         const tasks = state[action.payload.todolistId]         const index = tasks.findIndex(t => t.id === action.payload.taskId)         if (index > -1) {            tasks[index] = {...tasks[index], ...action.payload.model}         }      },      setTasksAC(state, action: PayloadAction<{ tasks: Array<TaskType>, todolistId: string }>) {         state[action.payload.todolistId] = action.payload.tasks      },      changeTaskEntityStatusAC(state, action: PayloadAction<{ taskId: string, entityStatus: RequestStatusType, todolistId: string }>) {         return {            ...state, [action.payload.todolistId]: state[action.payload.todolistId]               .map((t) => t.id === action.payload.taskId ? {...t, entityStatus: action.payload.entityStatus} : t)         }      },   },   extraReducers: (builder) => {      builder.addCase(addTodolistAC, (state, action) => {         state[action.payload.todolist.id] = []      })      builder.addCase(removeTodolistAC, (state, action) => {         delete state[action.payload.id]      })      builder.addCase(setTodolistsAC,(state, action) => {         action.payload.todolists.forEach((tl: TodolistType) => {            state[tl.id] = []         })      })   }})export const tasksReducer = slice.reducerexport const {removeTaskAC, updateTaskAC, setTasksAC, addTaskAC, changeTaskEntityStatusAC} = slice.actions// export const tasksReducer_ = (state: TasksStateType = initialState, action: any): TasksStateType => {//    switch (action.type) {////       case ACTIONS_TYPE.CHANGE_TASK_ENTITY_STATUS://          return {//             ...state, [action.payload.todolistId]: state[action.payload.todolistId]//                .map((t) => t.id === action.payload.taskId ? {...t, entityStatus: action.payload.entityStatus} : t)//          }//       default://          return state//    }// }// enumsexport enum ResponseCode {   success = 0,   failed = 1,   captcha = 10}// thunksexport const fetchTasksTC = (todolistId: string) => (dispatch: Dispatch) => {   dispatch(setAppStatusAC({status: 'loading'}))   tasksAPI.getTasks(todolistId)      .then((res) => {         const tasks = res.data.items         dispatch(setTasksAC({tasks, todolistId}))         dispatch(setAppStatusAC({status: 'succeeded'}))      })      .catch((error: AxiosError) => {         handleServerNetworkError(error.message, dispatch)      })}export const deleteTaskTC = (todolistId: string, taskId: string) => (dispatch: Dispatch) => {   dispatch(setAppStatusAC({status: 'loading'}))   dispatch(changeTaskEntityStatusAC({taskId, entityStatus: 'loading', todolistId}))   tasksAPI.deleteTask(todolistId, taskId)      .then(() => {         const action = removeTaskAC({todolistId, taskId})         dispatch(action)         dispatch(setAppStatusAC({status: 'succeeded'}))      })      .catch((error: AxiosError) => {         handleServerNetworkError(error.message, dispatch)      })}export const addTaskTC = (todolistId: string, title: string) => (dispatch: Dispatch) => {   dispatch(setAppStatusAC({status: 'loading'}))   tasksAPI.createTask(todolistId, title)      .then(res => {         if (res.data.resultCode === ResponseCode.success) {            dispatch(addTaskAC({task: res.data.data.item}))            dispatch(setAppStatusAC({status: 'succeeded'}))         } else {            handleServerAppError(res.data, dispatch)         }      })      .catch((error: AxiosError) => {         handleServerNetworkError(error.message, dispatch)      })}export const updateTaskTC = (taskId: string, domainModel: UpdateDomainTaskModelType, todolistId: string) =>   (dispatch: Dispatch, getState: () => AppRootStateType) => {      const state = getState()      const task = state.tasks[todolistId].find(t => t.id === taskId)      if (!task) {         console.warn('task not found in the state')         return      }      const apiModel: UpdateTaskModelType = {         title: task.title,         startDate: task.startDate,         priority: task.priority,         description: task.description,         deadline: task.deadline,         status: task.status,         ...domainModel      }      dispatch(setAppStatusAC({status: 'loading'}))      dispatch(changeTaskEntityStatusAC({taskId, entityStatus: 'loading', todolistId}))      tasksAPI.updateTask(todolistId, taskId, apiModel)         .then(() => {            dispatch(updateTaskAC({taskId, model: domainModel, todolistId}))            dispatch(setAppStatusAC({status: 'succeeded'}))            dispatch(changeTaskEntityStatusAC({taskId, entityStatus: 'idle', todolistId}))         })         .catch((error: AxiosError) => {            handleServerNetworkError(error.message, dispatch)         })   }// typestype UpdateDomainTaskModelType = {   title?: string   description?: string   status?: TaskStatuses   priority?: TaskPriorities   startDate?: string   deadline?: string}