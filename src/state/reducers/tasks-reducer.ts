import {AxiosError} from 'axios'import {createAsyncThunk, createSlice, PayloadAction} from '@reduxjs/toolkit'import {AppRootStateType} from '../store'import {RequestStatusType, setAppStatusAC} from './app-reducer'import {addTodolistTC, fetchTodolistsTC, removeTodolistTC, TasksStateType} from './todolists-reducer'import {TaskPriorities, tasksAPI, TaskStatuses, UpdateTaskModelType} from '../../api/tasks-api'import {TodolistType} from '../../api/todolists-api'import {handleServerAppError, handleServerNetworkError} from '../../utils/error-utils'// enumsexport enum ResponseCode {   success = 0,   failed = 1,   captcha = 10}// thunksexport const fetchTasksTC = createAsyncThunk('tasks/fetchTasks',   async (todolistId: string, {dispatch}) => {      dispatch(setAppStatusAC({status: 'loading'}))      const response = await tasksAPI.getTasks(todolistId)      const tasks = response.data.items      dispatch(setAppStatusAC({status: 'succeeded'}))      return {tasks, todolistId}   })export const deleteTaskTC = createAsyncThunk('tasks/deleteTasks',   async (param: { todolistId: string, taskId: string }, {dispatch}) => {      dispatch(setAppStatusAC({status: 'loading'}))      dispatch(changeTaskEntityStatusAC({         taskId: param.taskId, entityStatus: 'loading',         todolistId: param.todolistId      }))      await tasksAPI.deleteTask(param.todolistId, param.taskId)      dispatch(setAppStatusAC({status: 'succeeded'}))      return {todolistId: param.todolistId, taskId: param.taskId}   })export const addTaskTC = createAsyncThunk('task/addTask',   async (param: { todolistId: string, title: string }, {dispatch, rejectWithValue}) => {      dispatch(setAppStatusAC({status: 'loading'}))      try {         const response = await tasksAPI.createTask(param.todolistId, param.title)         if (response.data.resultCode === ResponseCode.success) {            const task = response.data.data.item            dispatch(setAppStatusAC({status: 'succeeded'}))            return task         } else {            handleServerAppError(response.data, dispatch)            return rejectWithValue(null)         }      } catch (err) {         const error: AxiosError = err         handleServerNetworkError(error.message, dispatch)         return rejectWithValue(null)      }   })export const updateTaskTC = createAsyncThunk('tasks/updateTask',   async (param: { taskId: string, model: UpdateDomainTaskModelType, todolistId: string }, {      dispatch,      rejectWithValue,      getState   }) => {      const state = getState() as AppRootStateType      const task = state.tasks[param.todolistId].find(t => t.id === param.taskId)      if (!task) {         return rejectWithValue('task not found in the state')      }      const apiModel: UpdateTaskModelType = {         title: task.title,         startDate: task.startDate,         priority: task.priority,         description: task.description,         deadline: task.deadline,         status: task.status,         ...param.model      }      try {         dispatch(setAppStatusAC({status: 'loading'}))         dispatch(changeTaskEntityStatusAC({            taskId: param.taskId,            entityStatus: 'loading',            todolistId: param.todolistId         }))         const response = await tasksAPI.updateTask(param.todolistId, param.taskId, apiModel)         if (response.data.resultCode === ResponseCode.success) {            dispatch(setAppStatusAC({status: 'succeeded'}))            dispatch(changeTaskEntityStatusAC({               taskId: param.taskId,               entityStatus: 'idle',               todolistId: param.todolistId            }))            return param         } else {            handleServerAppError(response.data, dispatch)            return rejectWithValue(null)         }      } catch (err) {         const error: AxiosError = err         handleServerNetworkError(error.message, dispatch)         return rejectWithValue(null)      }   })const slice = createSlice({   name: 'tasks',   initialState: {} as TasksStateType,   reducers: {      changeTaskEntityStatusAC(state, action: PayloadAction<{ taskId: string, entityStatus: RequestStatusType, todolistId: string }>) {         return {            ...state, [action.payload.todolistId]: state[action.payload.todolistId]               .map((t) => t.id === action.payload.taskId ? {...t, entityStatus: action.payload.entityStatus} : t)         }      },   },   extraReducers: builder => {      builder.addCase(addTodolistTC.fulfilled, (state, action) => {         state[action.payload.todolist.id] = []      })      builder.addCase(removeTodolistTC.fulfilled, (state, action) => {         delete state[action.payload.id]      })      builder.addCase(fetchTodolistsTC.fulfilled, (state, action) => {         action.payload.todolists.forEach((tl: TodolistType) => {            state[tl.id] = []         })      })      builder.addCase(fetchTasksTC.fulfilled, (state, action) => {         state[action.payload.todolistId] = action.payload.tasks      })      builder.addCase(deleteTaskTC.fulfilled, (state, action) => {         const tasks = state[action.payload.todolistId]         const index = tasks.findIndex(t => t.id === action.payload.taskId)         if (index > -1) {            tasks.splice(index, 1)         }      })      builder.addCase(addTaskTC.fulfilled, (state, action) => {         state[action.payload.todoListId].unshift(action.payload)      })      builder.addCase(updateTaskTC.fulfilled, (state, action) => {         const tasks = state[action.payload.todolistId]         if (tasks) {            const index = tasks.findIndex(t => t.id === action.payload.taskId)            if (index > -1) {               tasks[index] = {...tasks[index], ...action.payload.model}            }         }      })   }})export const tasksReducer = slice.reducerexport const {changeTaskEntityStatusAC} = slice.actions// thunks// export const fetchTasksTC = (todolistId: string) => (dispatch: Dispatch) => {//    dispatch(setAppStatusAC({status: 'loading'}))//    tasksAPI.getTasks(todolistId)//       .then((res) => {//          const tasks = res.data.items//          dispatch(setTasksAC({tasks, todolistId}))//          dispatch(setAppStatusAC({status: 'succeeded'}))//       })//       .catch((error: AxiosError) => {//          handleServerNetworkError(error.message, dispatch)//       })// }// export const deleteTaskTC = (todolistId: string, taskId: string) => (dispatch: Dispatch) => {//    dispatch(setAppStatusAC({status: 'loading'}))//    dispatch(changeTaskEntityStatusAC({taskId, entityStatus: 'loading', todolistId}))//    tasksAPI.deleteTask(todolistId, taskId)//       .then(() => {//          const action = removeTaskAC({todolistId, taskId})//          dispatch(action)//          dispatch(setAppStatusAC({status: 'succeeded'}))//       })//       .catch((error: AxiosError) => {//          handleServerNetworkError(error.message, dispatch)//       })// }// export const addTaskTC = (todolistId: string, title: string) => (dispatch: Dispatch) => {//    dispatch(setAppStatusAC({status: 'loading'}))//    tasksAPI.createTask(todolistId, title)//       .then(res => {//          if (res.data.resultCode === ResponseCode.success) {//             const task = res.data.data.item//             dispatch(addTaskAC(task))//             dispatch(setAppStatusAC({status: 'succeeded'}))//          } else {//             handleServerAppError(res.data, dispatch)//          }//       })//       .catch((error: AxiosError) => {//          handleServerNetworkError(error.message, dispatch)//       })// }// export const updateTaskTC = (taskId: string, domainModel: UpdateDomainTaskModelType, todolistId: string) => (dispatch: Dispatch, getState: () => AppRootStateType) => {//    const state = getState()//    const task = state.tasks[todolistId].find(t => t.id === taskId)//    if (!task) {//       console.warn('task not found in the state')//       return//    }//    const apiModel: UpdateTaskModelType = {//       title: task.title,//       startDate: task.startDate,//       priority: task.priority,//       description: task.description,//       deadline: task.deadline,//       status: task.status,//       ...domainModel//    }//    dispatch(setAppStatusAC({status: 'loading'}))//    dispatch(changeTaskEntityStatusAC({taskId, entityStatus: 'loading', todolistId}))//    tasksAPI.updateTask(todolistId, taskId, apiModel)//       .then(() => {//          dispatch(updateTaskAC({taskId, model: domainModel, todolistId}))//          dispatch(setAppStatusAC({status: 'succeeded'}))//          dispatch(changeTaskEntityStatusAC({taskId, entityStatus: 'idle', todolistId}))//       })//       .catch((error: AxiosError) => {//          handleServerNetworkError(error.message, dispatch)//       })// }// typestype UpdateDomainTaskModelType = {   title?: string   description?: string   status?: TaskStatuses   priority?: TaskPriorities   startDate?: string   deadline?: string}