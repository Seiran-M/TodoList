import {Dispatch} from 'redux'import {createAsyncThunk, createSlice, PayloadAction} from '@reduxjs/toolkit'import {authAPI, FieldErrorType, LoginParamsType} from '../../api/auth-api'import {setAppStatusAC} from './app-reducer'import {handleServerAppError, handleServerNetworkError} from '../../utils/error-utils'import {AxiosError} from 'axios'// enumsexport enum ResponseCode {   success = 0,   failed = 1,   captcha = 10}export const loginTC = createAsyncThunk<{ isLoggedIn: boolean }, LoginParamsType, {      rejectValue: { errors: Array<string>, fieldsErrors?: Array<FieldErrorType> }   }>('auth/login', async (data, thunkAPI) => {   thunkAPI.dispatch(setAppStatusAC({status: 'loading'}))   try {      const response = await authAPI.login(data)      if (response.data.resultCode === ResponseCode.success) {         thunkAPI.dispatch(setAppStatusAC({status: 'succeeded'}))         return {isLoggedIn: true}      } else {         handleServerAppError(response.data, thunkAPI.dispatch)         return thunkAPI.rejectWithValue({errors: response.data.messages, fieldsErrors: response.data.fieldsErrors})      }   } catch (err) {      const error: AxiosError = err      handleServerNetworkError(error.message, thunkAPI.dispatch)      return thunkAPI.rejectWithValue({errors: [error.message], fieldsErrors: undefined})   }})const slice = createSlice({   name: 'auth',   initialState: {      isLoggedIn: false   },   reducers: {      setIsLoggedInAC(state, action: PayloadAction<{ value: boolean }>) {         state.isLoggedIn = action.payload.value      }   },   extraReducers: builder => {      builder.addCase(loginTC.fulfilled, (state, action) => {         state.isLoggedIn = action.payload.isLoggedIn      })   }})export const authReducer = slice.reducerexport const {setIsLoggedInAC} = slice.actions// thunksexport const logoutTC = () => (dispatch: Dispatch) => {   dispatch(setAppStatusAC({status: 'loading'}))   authAPI.logout()      .then(response => {         if (response.data.resultCode === ResponseCode.success) {            dispatch(setIsLoggedInAC({value: false}))            dispatch(setAppStatusAC({status: 'succeeded'}))         } else {            handleServerAppError(response.data, dispatch)         }      })      .catch((error) => {         handleServerNetworkError(error, dispatch)      })}// types// export type AuthStateType = {//    isLoggedIn:boolean,// }// type ActionsType =//    ReturnType<typeof setIsLoggedInAC>//    | ReturnType<typeof setAppStatusAC>//    | ReturnType<typeof setAppErrorAC>